#include <iostream>
#include <vector>
#include <complex.h>
#include <cmath>
#include "dsp.hpp"
using std::vector;
using namespace std;
using namespace utils;

// LLR (Exact and Approx)W

namespace comm {

    vector<complex<float>> QAM = {{-0.7071, -0.7071}, {-0.7071, 0.7071}, {0.7071, -0.7071}, {0.7071, 0.7071}, {-0.7071, -0.7071}, {-0.7071, -0.2357}, {-0.7071, 0.2357}, {-0.7071, 0.7071}, {-0.2357, -0.7071}, {-0.2357, -0.2357}, {-0.2357, 0.2357}, {-0.2357, 0.7071}, {0.2357, -0.7071}, {0.2357, -0.2357}, {0.2357, 0.2357}, {0.2357, 0.7071}, {0.7071, -0.7071}, {0.7071, -0.2357}, {0.7071, 0.2357}, {0.7071, 0.7071}, {-0.7071, -0.7071}, {-0.7071, -0.5051}, {-0.7071, -0.303}, {-0.7071, -0.101}, {-0.7071, 0.101}, {-0.7071, 0.303}, {-0.7071, 0.5051}, {-0.7071, 0.7071}, {-0.5051, -0.7071}, {-0.5051, -0.5051}, {-0.5051, -0.303}, {-0.5051, -0.101}, {-0.5051, 0.101}, {-0.5051, 0.303}, {-0.5051, 0.5051}, {-0.5051, 0.7071}, {-0.303, -0.7071}, {-0.303, -0.5051}, {-0.303, -0.303}, {-0.303, -0.101}, {-0.303, 0.101}, {-0.303, 0.303}, {-0.303, 0.5051}, {-0.303, 0.7071}, {-0.101, -0.7071}, {-0.101, -0.5051}, {-0.101, -0.303}, {-0.101, -0.101}, {-0.101, 0.101}, {-0.101, 0.303}, {-0.101, 0.5051}, {-0.101, 0.7071}, {0.101, -0.7071}, {0.101, -0.5051}, {0.101, -0.303}, {0.101, -0.101}, {0.101, 0.101}, {0.101, 0.303}, {0.101, 0.5051}, {0.101, 0.7071}, {0.303, -0.7071}, {0.303, -0.5051}, {0.303, -0.303}, {0.303, -0.101}, {0.303, 0.101}, {0.303, 0.303}, {0.303, 0.5051}, {0.303, 0.7071}, {0.5051, -0.7071}, {0.5051, -0.5051}, {0.5051, -0.303}, {0.5051, -0.101}, {0.5051, 0.101}, {0.5051, 0.303}, {0.5051, 0.5051}, {0.5051, 0.7071}, {0.7071, -0.7071}, {0.7071, -0.5051}, {0.7071, -0.303}, {0.7071, -0.101}, {0.7071, 0.101}, {0.7071, 0.303}, {0.7071, 0.5051}, {0.7071, 0.7071}, {-0.7071, -0.7071}, {-0.7071, -0.6128}, {-0.7071, -0.5185}, {-0.7071, -0.4243}, {-0.7071, -0.33}, {-0.7071, -0.2357}, {-0.7071, -0.1414}, {-0.7071, -0.0471}, {-0.7071, 0.0471}, {-0.7071, 0.1414}, {-0.7071, 0.2357}, {-0.7071, 0.33}, {-0.7071, 0.4243}, {-0.7071, 0.5185}, {-0.7071, 0.6128}, {-0.7071, 0.7071}, {-0.6128, -0.7071}, {-0.6128, -0.6128}, {-0.6128, -0.5185}, {-0.6128, -0.4243}, {-0.6128, -0.33}, {-0.6128, -0.2357}, {-0.6128, -0.1414}, {-0.6128, -0.0471}, {-0.6128, 0.0471}, {-0.6128, 0.1414}, {-0.6128, 0.2357}, {-0.6128, 0.33}, {-0.6128, 0.4243}, {-0.6128, 0.5185}, {-0.6128, 0.6128}, {-0.6128, 0.7071}, {-0.5185, -0.7071}, {-0.5185, -0.6128}, {-0.5185, -0.5185}, {-0.5185, -0.4243}, {-0.5185, -0.33}, {-0.5185, -0.2357}, {-0.5185, -0.1414}, {-0.5185, -0.0471}, {-0.5185, 0.0471}, {-0.5185, 0.1414}, {-0.5185, 0.2357}, {-0.5185, 0.33}, {-0.5185, 0.4243}, {-0.5185, 0.5185}, {-0.5185, 0.6128}, {-0.5185, 0.7071}, {-0.4243, -0.7071}, {-0.4243, -0.6128}, {-0.4243, -0.5185}, {-0.4243, -0.4243}, {-0.4243, -0.33}, {-0.4243, -0.2357}, {-0.4243, -0.1414}, {-0.4243, -0.0471}, {-0.4243, 0.0471}, {-0.4243, 0.1414}, {-0.4243, 0.2357}, {-0.4243, 0.33}, {-0.4243, 0.4243}, {-0.4243, 0.5185}, {-0.4243, 0.6128}, {-0.4243, 0.7071}, {-0.33, -0.7071}, {-0.33, -0.6128}, {-0.33, -0.5185}, {-0.33, -0.4243}, {-0.33, -0.33}, {-0.33, -0.2357}, {-0.33, -0.1414}, {-0.33, -0.0471}, {-0.33, 0.0471}, {-0.33, 0.1414}, {-0.33, 0.2357}, {-0.33, 0.33}, {-0.33, 0.4243}, {-0.33, 0.5185}, {-0.33, 0.6128}, {-0.33, 0.7071}, {-0.2357, -0.7071}, {-0.2357, -0.6128}, {-0.2357, -0.5185}, {-0.2357, -0.4243}, {-0.2357, -0.33}, {-0.2357, -0.2357}, {-0.2357, -0.1414}, {-0.2357, -0.0471}, {-0.2357, 0.0471}, {-0.2357, 0.1414}, {-0.2357, 0.2357}, {-0.2357, 0.33}, {-0.2357, 0.4243}, {-0.2357, 0.5185}, {-0.2357, 0.6128}, {-0.2357, 0.7071}, {-0.1414, -0.7071}, {-0.1414, -0.6128}, {-0.1414, -0.5185}, {-0.1414, -0.4243}, {-0.1414, -0.33}, {-0.1414, -0.2357}, {-0.1414, -0.1414}, {-0.1414, -0.0471}, {-0.1414, 0.0471}, {-0.1414, 0.1414}, {-0.1414, 0.2357}, {-0.1414, 0.33}, {-0.1414, 0.4243}, {-0.1414, 0.5185}, {-0.1414, 0.6128}, {-0.1414, 0.7071}, {-0.0471, -0.7071}, {-0.0471, -0.6128}, {-0.0471, -0.5185}, {-0.0471, -0.4243}, {-0.0471, -0.33}, {-0.0471, -0.2357}, {-0.0471, -0.1414}, {-0.0471, -0.0471}, {-0.0471, 0.0471}, {-0.0471, 0.1414}, {-0.0471, 0.2357}, {-0.0471, 0.33}, {-0.0471, 0.4243}, {-0.0471, 0.5185}, {-0.0471, 0.6128}, {-0.0471, 0.7071}, {0.0471, -0.7071}, {0.0471, -0.6128}, {0.0471, -0.5185}, {0.0471, -0.4243}, {0.0471, -0.33}, {0.0471, -0.2357}, {0.0471, -0.1414}, {0.0471, -0.0471}, {0.0471, 0.0471}, {0.0471, 0.1414}, {0.0471, 0.2357}, {0.0471, 0.33}, {0.0471, 0.4243}, {0.0471, 0.5185}, {0.0471, 0.6128}, {0.0471, 0.7071}, {0.1414, -0.7071}, {0.1414, -0.6128}, {0.1414, -0.5185}, {0.1414, -0.4243}, {0.1414, -0.33}, {0.1414, -0.2357}, {0.1414, -0.1414}, {0.1414, -0.0471}, {0.1414, 0.0471}, {0.1414, 0.1414}, {0.1414, 0.2357}, {0.1414, 0.33}, {0.1414, 0.4243}, {0.1414, 0.5185}, {0.1414, 0.6128}, {0.1414, 0.7071}, {0.2357, -0.7071}, {0.2357, -0.6128}, {0.2357, -0.5185}, {0.2357, -0.4243}, {0.2357, -0.33}, {0.2357, -0.2357}, {0.2357, -0.1414}, {0.2357, -0.0471}, {0.2357, 0.0471}, {0.2357, 0.1414}, {0.2357, 0.2357}, {0.2357, 0.33}, {0.2357, 0.4243}, {0.2357, 0.5185}, {0.2357, 0.6128}, {0.2357, 0.7071}, {0.33, -0.7071}, {0.33, -0.6128}, {0.33, -0.5185}, {0.33, -0.4243}, {0.33, -0.33}, {0.33, -0.2357}, {0.33, -0.1414}, {0.33, -0.0471}, {0.33, 0.0471}, {0.33, 0.1414}, {0.33, 0.2357}, {0.33, 0.33}, {0.33, 0.4243}, {0.33, 0.5185}, {0.33, 0.6128}, {0.33, 0.7071}, {0.4243, -0.7071}, {0.4243, -0.6128}, {0.4243, -0.5185}, {0.4243, -0.4243}, {0.4243, -0.33}, {0.4243, -0.2357}, {0.4243, -0.1414}, {0.4243, -0.0471}, {0.4243, 0.0471}, {0.4243, 0.1414}, {0.4243, 0.2357}, {0.4243, 0.33}, {0.4243, 0.4243}, {0.4243, 0.5185}, {0.4243, 0.6128}, {0.4243, 0.7071}, {0.5185, -0.7071}, {0.5185, -0.6128}, {0.5185, -0.5185}, {0.5185, -0.4243}, {0.5185, -0.33}, {0.5185, -0.2357}, {0.5185, -0.1414}, {0.5185, -0.0471}, {0.5185, 0.0471}, {0.5185, 0.1414}, {0.5185, 0.2357}, {0.5185, 0.33}, {0.5185, 0.4243}, {0.5185, 0.5185}, {0.5185, 0.6128}, {0.5185, 0.7071}, {0.6128, -0.7071}, {0.6128, -0.6128}, {0.6128, -0.5185}, {0.6128, -0.4243}, {0.6128, -0.33}, {0.6128, -0.2357}, {0.6128, -0.1414}, {0.6128, -0.0471}, {0.6128, 0.0471}, {0.6128, 0.1414}, {0.6128, 0.2357}, {0.6128, 0.33}, {0.6128, 0.4243}, {0.6128, 0.5185}, {0.6128, 0.6128}, {0.6128, 0.7071}, {0.7071, -0.7071}, {0.7071, -0.6128}, {0.7071, -0.5185}, {0.7071, -0.4243}, {0.7071, -0.33}, {0.7071, -0.2357}, {0.7071, -0.1414}, {0.7071, -0.0471}, {0.7071, 0.0471}, {0.7071, 0.1414}, {0.7071, 0.2357}, {0.7071, 0.33}, {0.7071, 0.4243}, {0.7071, 0.5185}, {0.7071, 0.6128}, {0.7071, 0.7071}};

    vector<complex<float>> QAMMod(vector<int> data, int M, int size) {
        // Number of bits per symbol
        int bitsPerSym = log2(M);

        // Total number of QAM Symbols

        int numSyms = size / bitsPerSym;

        // Buffer for output modulated vector
        vector<complex<float>> modData(numSyms);

        // Iterating over the groups of bits (symbols)
        for (int iter_sym = 0; iter_sym < numSyms; iter_sym++) {
            // Variable representing the symbol in decimal form
            int modIdx = 0;
            // Iterating over each bit in symbol
            for (int iter_bits = 0; iter_bits < bitsPerSym; iter_bits++) {
                // Bit shifting and forming decimal symbol
                modIdx = modIdx << 1;
                modIdx ^= data[iter_sym * bitsPerSym + iter_bits];
            }
            // QAM Modulation from lookup array using symbol as index
            modIdx = (M > 4) * 4 + (M > 16) * 16 + (M > 64) * 64 + modIdx;
            
            modData[iter_sym] = QAM[modIdx];
        }

        return modData;    
    }
    
    vector<int> QAMDemod(vector<complex<float>> modData, int M, int size, int softOut, float noiseVar) {
        float dist = 1000;
        int distIdx = 0;
        float dist_tmp = 0;
        int bitsPerSym = log2(M);
        int modIdx = (M > 4) * 4 + (M > 16) * 16 + (M > 64) * 64;
            
        vector<int> demodOut(size * bitsPerSym);

        if (softOut == 0) { // Hard Output
            for (int iter_data = 0; iter_data < size; iter_data++) {
                
                // Iterating over all constellation points and finding the nearest
                // point (smallest euclidean distance)
                for (int iter_const = 0; iter_const < M; iter_const++) {
                    dist_tmp = cAbsDiffSqr(modData[iter_data], QAM[modIdx + iter_const]);   
                    if (dist_tmp <= dist) {
                        distIdx = modIdx + iter_const;
                        dist = dist_tmp;
                    } 
                }

                // Converting decimal symbol into bits
                for (int iter_bits = 0; iter_bits < bitsPerSym; iter_bits++) {
                    demodOut[iter_data * bitsPerSym + bitsPerSym - iter_bits - 1] = distIdx % 2;
                    distIdx /= 2;
                }
            }
        } else if (softOut == 1) { // Soft Output (Exact LLR)
            for (int iter_data = 0; iter_data < size; iter_data++) {
                for (int iter_bits = 0; iter_bits < bitsPerSym; iter_bits++) {
                    float lkhd0 = 0, lkhd1 = 0;
                    for (int iter_const = 0; iter_const < M; iter_const++) {
                        if (iter_const ^ int(pow(2, iter_bits)) == 0) {
                            lkhd0 += exp((-1 / (2 * noiseVar)) * ((QAM[iter_const].real() - modData[iter_data].real()) * (QAM[iter_const].real() - modData[iter_data].real()) + (QAM[iter_const].imag() - modData[iter_data].imag()) * (QAM[iter_const].imag() - modData[iter_data].imag())));
                        } else {
                            lkhd1 += exp((-1 / (2 * noiseVar)) * ((QAM[iter_const].real() - modData[iter_data].real()) * (QAM[iter_const].real() - modData[iter_data].real()) + (QAM[iter_const].imag() - modData[iter_data].imag()) * (QAM[iter_const].imag() - modData[iter_data].imag())));
                        }
                    }
                    demodOut[iter_data * bitsPerSym + iter_bits] = log(lkhd0 / lkhd1);
                }
            }
        } else if (softOut == 2) { // Soft Output (Approx. LLR)
            for (int iter_data = 0; iter_data < size; iter_data++) {
                for (int iter_bits = 0; iter_bits < bitsPerSym; iter_bits++) {
                    float lkhd0 = 1e10, lkhd1 = 1e10, tmp1, tmp2;
                    for (int iter_const = 0; iter_const < M; iter_const++) {
                        if (iter_const ^ int(pow(2, iter_bits)) == 0) {
                            tmp1 = exp((-1 / (2 * noiseVar)) * ((QAM[iter_const].real() - modData[iter_data].real()) * (QAM[iter_const].real() - modData[iter_data].real()) + (QAM[iter_const].imag() - modData[iter_data].imag()) * (QAM[iter_const].imag() - modData[iter_data].imag())));
                            if (tmp1 < lkhd0) {
                                lkhd0 = tmp1;
                            }
                        } else {
                            tmp2 = exp((-1 / (2 * noiseVar)) * ((QAM[iter_const].real() - modData[iter_data].real()) * (QAM[iter_const].real() - modData[iter_data].real()) + (QAM[iter_const].imag() - modData[iter_data].imag()) * (QAM[iter_const].imag() - modData[iter_data].imag())));
                            if (tmp2 < lkhd1) {
                                lkhd1 = tmp2;
                            }
                        }
                    }
                    demodOut[iter_data * bitsPerSym + iter_bits] = log(lkhd0 / lkhd1);
                }
            }
        }

        return demodOut;
    }
}